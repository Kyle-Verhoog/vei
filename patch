diff --git a/src/main/scala/compiler/joos1w/ast/AST.scala b/src/main/scala/compiler/joos1w/ast/AST.scala
index 123003f..a24c7df 100644
--- a/src/main/scala/compiler/joos1w/ast/AST.scala
+++ b/src/main/scala/compiler/joos1w/ast/AST.scala
@@ -1163,6 +1163,31 @@ object AST {
     }
   }
 
+  /**
+    * @tparam K type of keys in the result map
+    * @tparam V type of values in the result map
+    * @tparam T type of ASTNode to operate on
+    * @return
+    */
+  def visit[R](
+      fn: (Option[AST], R => R, R => R) => R,
+      ast: Option[AST],
+      acc: R,
+  ): R = {
+    val acrossRec = (acc: R) =>
+      ast match {
+        case Some(ast) => visit(fn, ast.rightSibling, acc)
+        case None      => acc
+    }
+    val downRec = (acc: R) =>
+      ast match {
+        case Some(ast) => visit(fn, ast.leftChild, acc)
+        case None      => acc
+    }
+
+    fn(ast, acrossRec, downRec)
+  }
+
   /**
     * @tparam K type of keys in the result map
     * @tparam V type of values in the result map
diff --git a/src/main/scala/compiler/joos1w/ast/Empty.scala b/src/main/scala/compiler/joos1w/ast/Empty.scala
index 74908b4..a4f0ff0 100644
--- a/src/main/scala/compiler/joos1w/ast/Empty.scala
+++ b/src/main/scala/compiler/joos1w/ast/Empty.scala
@@ -1,6 +1,6 @@
 package compiler.joos1w.ast
 
-class Empty(fieldName: String = "") extends AST {
+class Empty(val fieldName: String = "") extends AST {
   override def strFields: String = {
     s"$fieldName"
   }
diff --git a/src/main/scala/compiler/joos1w/env/Class.scala b/src/main/scala/compiler/joos1w/env/Class.scala
index 36b71ff..f2b00d1 100644
--- a/src/main/scala/compiler/joos1w/env/Class.scala
+++ b/src/main/scala/compiler/joos1w/env/Class.scala
@@ -16,4 +16,8 @@ class Class(val parent: Package, ast: ClassDeclaration) extends Env {
   override def toString: String = {
     s"ClassEnv($name)"
   }
+
+  override def toStrTree: String = {
+    toString
+  }
 }
diff --git a/src/main/scala/compiler/joos1w/env/Env.scala b/src/main/scala/compiler/joos1w/env/Env.scala
index 06f2755..7c38112 100644
--- a/src/main/scala/compiler/joos1w/env/Env.scala
+++ b/src/main/scala/compiler/joos1w/env/Env.scala
@@ -3,5 +3,9 @@ package compiler.joos1w.env
 abstract class Env() {
   def lookup(name: Name): Option[Env]
 
+  // namespace???
+
   def globalLookup(name: Name): Option[Env]
+
+  def toStrTree: String
 }
diff --git a/src/main/scala/compiler/joos1w/env/Package.scala b/src/main/scala/compiler/joos1w/env/Package.scala
index 22298c8..8287f98 100644
--- a/src/main/scala/compiler/joos1w/env/Package.scala
+++ b/src/main/scala/compiler/joos1w/env/Package.scala
@@ -1,44 +1,48 @@
 package compiler.joos1w.env
 
-import compiler.joos1w.ast.{AST, ClassDeclaration, PackageDeclaration}
+import compiler.joos1w.ast.{AST, Empty, ClassDeclaration, PackageDeclaration}
 
 object Package {}
 
-class Package(val parent: Root, val ast: PackageDeclaration) extends Env {
-  val name: PackageName = new PackageName(ast.name)
+class Package(val parent: Root, val ast: Either[PackageDeclaration, Empty])
+    extends Env {
+  val name: PackageName = ast match {
+    case Left(pkgAST)    => new PackageName(pkgAST.name)
+    case Right(emptyAST) => PackageName.ROOT
+  }
 
-  type ClassMap = Map[Name, Class]
-  var classes: ClassMap =
-    AST.foldUp[ClassDeclaration, ClassMap](
+  type Namespace = Map[Name, Class]
+  var namespace: Namespace =
+    AST.foldUp[ClassDeclaration, Namespace](
       (ast, accMap) => {
         val cls = new Class(this, ast)
         accMap + (cls.name -> cls)
       },
-      Some(ast),
+      ast.fold(a => Some(a), a => Some(a)),
       Map(),
       AST.RecursionOptions(true, true, true, (m1, m2) => m1 ++ m2)
     )
 
   def addClass(cls: Class): Package = {
-    classes = classes + (cls.name -> cls)
+    namespace = namespace + (cls.name -> cls)
     this
   }
 
   def numClasses: Int = {
-    classes.size
+    namespace.size
   }
 
   def hasClass(name: Name): Boolean = {
-    println(name, classes)
-    classes.contains(name)
+    println(name, namespace)
+    namespace.contains(name)
   }
 
   def getClass(name: Name): Option[Class] = {
-    if (hasClass(name)) Some(classes(name)) else None
+    if (hasClass(name)) Some(namespace(name)) else None
   }
 
   def getAllClasses: List[Class] = {
-    classes.foldLeft(Nil: List[Class]) {
+    namespace.foldLeft(Nil: List[Class]) {
       case (acc, (_, cls)) =>
         cls :: acc
     }
@@ -48,10 +52,30 @@ class Package(val parent: Root, val ast: PackageDeclaration) extends Env {
     if (other.name != name) {
       throw new RuntimeException()
     }
-    classes = classes ++ other.classes
+    namespace = namespace ++ other.namespace
     this
   }
 
+  override def toString: String = {
+    s"Package(${namespace.size})"
+  }
+
+  override def toStrTree: String = {
+    val cs: List[String] = namespace.toList
+      .map({
+        case (name: Name, cls: Class) =>
+          val childStrs = cls.toStrTree.split("\n")
+          val tailChar = if (childStrs.tail.isEmpty) "" else "\n"
+          s"┠─ " + childStrs.head + tailChar + childStrs.tail
+            .map(
+              line => "┃  " + line
+            )
+            .mkString("\n")
+      })
+    val scs = cs.mkString("\n")
+    s"$toString\n$scs"
+  }
+
   override def globalLookup(name: Name): Option[Env] = {
     parent.globalLookup(name)
   }
diff --git a/src/main/scala/compiler/joos1w/env/Root.scala b/src/main/scala/compiler/joos1w/env/Root.scala
index c041da5..48759c7 100644
--- a/src/main/scala/compiler/joos1w/env/Root.scala
+++ b/src/main/scala/compiler/joos1w/env/Root.scala
@@ -13,9 +13,8 @@ object Root {
 }
 
 class Root(val asts: List[AST]) extends Env {
-  private val emptyAST = new PackageDeclaration()
-  emptyAST.addChildToEnd(new compiler.joos1w.ast.Name(""))
-  private val EmptyPackage = new Package(this, emptyAST)
+  private val emptyAST = new Empty()
+  private val EmptyPackage = new Package(this, Right(emptyAST))
 
   type Namespace = Map[Name, Option[Env]]
 
@@ -67,13 +66,25 @@ class Root(val asts: List[AST]) extends Env {
   }
 
   def packageFromAST(ast: Option[AST]): Package = {
-    // TODO: have to look for Empty packages
-    val pkgs: List[Package] = AST.foldUp[PackageDeclaration, List[Package]](
-      (ast, acc) => new Package(this, ast) :: acc,
-      ast,
-      List(),
-      AST.RecursionOptions(true, true, true, (r1, r2) => r1 ++ r2)
-    ) ++ List(EmptyPackage)
+    val pkgs: List[Package] =
+      AST.visit(
+        (ast: Option[AST],
+         acrossRec: List[Package] => List[Package],
+         downRec: List[Package] => List[Package]) => {
+          ast match {
+            case Some(pkgAST: PackageDeclaration) =>
+              List(new Package(this, Left(pkgAST)))
+            case Some(emptyAST: Empty) =>
+              if (emptyAST.fieldName == "package_declaration")
+                List(new Package(this, Right(emptyAST)))
+              else Nil
+            case None => Nil
+            case _    => downRec(Nil) ++ acrossRec(Nil)
+          }
+        },
+        ast,
+        List()
+      )
     pkgs.head
   }
 
@@ -147,6 +158,38 @@ class Root(val asts: List[AST]) extends Env {
       .toList
   }
 
+  override def toStrTree: String = {
+    val cs: List[String] = namespace.toList
+      .map({
+        case (name: Name, item: Option[Env]) =>
+          item match {
+            case Some(env: Env) =>
+              val childStrs = env.toStrTree.split("\n")
+              val tailChar = if (childStrs.tail.isEmpty) "" else "\n"
+              s"┠─ " + childStrs.head + tailChar + childStrs.tail
+                .map(
+                  line => "┃  " + line
+                )
+                .mkString("\n")
+            case None => s"$name: None"
+            case _    => ""
+          }
+      })
+    val scs = cs.mkString("\n")
+    s"$toString\n$cs"
+  }
+
+  override def toString: String = {
+    val (nPackages, nClasses) = namespace.keys.foldLeft[(Int, Int)]((0, 0))({
+      case ((npkg, ncls), name) =>
+        name match {
+          case _: PackageName => (npkg + 1, ncls)
+          case _: ClassName   => (npkg, ncls + 1)
+        }
+    })
+    s"Environment(npackages: $nPackages, nclasses: $nClasses)"
+  }
+
   override def lookup(qualifiedName: Name): Option[Env] = {
     None
   }
diff --git a/src/test/scala/joos1w/EnvTest.scala b/src/test/scala/joos1w/EnvTest.scala
index ac1ae23..402a4b8 100644
--- a/src/test/scala/joos1w/EnvTest.scala
+++ b/src/test/scala/joos1w/EnvTest.scala
@@ -84,7 +84,7 @@ class EnvTest extends FunSuite {
     println("\n\n")
     var root = new Root(List(ABCA, BC))
     root.addPackagesFromASTs()
-    println(root.getAllClasses)
+    println(root)
     assert(root.hasPackage(PackageName("A.B.C")))
     assert(
       root
@@ -113,12 +113,14 @@ class EnvTest extends FunSuite {
 
     println("\n\n\n\n\n")
     // Root package
+  }
+
+  test("Root package") {
     val A = TestUtils.ASTForSrc(s"""
-                                    |public class A {}
+                                   |public class A {}
        """.stripMargin)
-    root = new Root(List(A))
+    val root = new Root(List(A))
     root.addPackagesFromASTs()
-    println(root.)
     assert(root.hasItem(new ClassName(PackageName.ROOT, "A")))
   }
 
